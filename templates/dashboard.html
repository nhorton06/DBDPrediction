<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dead by Daylight - Analytics Dashboard</title>
    <link rel="icon" type="image/png" href="/assets/icon.png">
    <link rel="shortcut icon" type="image/png" href="/assets/icon.png">
    <link href="https://fonts.googleapis.com/css2?family=Creepster&family=Orbitron:wght@400;700;900&family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        :root {
            /* Dark theme (default) */
            --bg-primary: #0a0a0a;
            --bg-secondary: #1a1a1a;
            --bg-tertiary: #0d0d0d;
            --text-primary: #e0e0e0;
            --text-secondary: #aaa;
            --border-color: #3a0000;
            --accent-red: #ff1a1a;
            --accent-red-dark: #8b0000;
            --container-bg: linear-gradient(145deg, #1a1a1a 0%, #0d0d0d 100%);
            --scrollbar-track: #0d0d0d;
            --scrollbar-thumb: linear-gradient(135deg, #8b0000 0%, #600000 100%);
            /* Success/Failure colors (green/red by default) */
            --color-success: #4dff4d;
            --color-success-light: #66ff66;
            --color-failure: #ff6666;
            --color-failure-light: #ff8888;
        }
        
        [data-theme="light"] {
            /* Light theme */
            --bg-primary: #f5f5f5;
            --bg-secondary: #ffffff;
            --bg-tertiary: #e8e8e8;
            --text-primary: #1a1a1a;
            --text-secondary: #555;
            --border-color: #ccc;
            --accent-red: #d32f2f;
            --accent-red-dark: #b71c1c;
            --container-bg: linear-gradient(145deg, #ffffff 0%, #f5f5f5 100%);
            --scrollbar-track: #e8e8e8;
            --scrollbar-thumb: linear-gradient(135deg, #d32f2f 0%, #b71c1c 100%);
            /* Success/Failure colors (green/red) */
            --color-success: #4dff4d;
            --color-success-light: #66ff66;
            --color-failure: #ff6666;
            --color-failure-light: #ff8888;
        }
        
        [data-theme="colorblind"] {
            /* Colorblind/High Contrast theme - uses blue/orange instead of green/red */
            --bg-primary: #0a0a0a;
            --bg-secondary: #1a1a1a;
            --bg-tertiary: #0d0d0d;
            --text-primary: #e0e0e0;
            --text-secondary: #aaa;
            --border-color: #663300;
            --accent-red: #ff9933;
            --accent-red-dark: #cc7700;
            --container-bg: linear-gradient(145deg, #1a1a1a 0%, #0d0d0d 100%);
            --scrollbar-track: #0d0d0d;
            --scrollbar-thumb: linear-gradient(135deg, #cc7700 0%, #994400 100%);
            /* Success/Failure colors (blue/orange for colorblind accessibility) */
            --color-success: #4da6ff;
            --color-success-light: #66b3ff;
            --color-failure: #ff9933;
            --color-failure-light: #ffaa55;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Roboto', sans-serif;
            background: var(--bg-primary);
            background-image: 
                radial-gradient(circle at 20% 50%, rgba(139, 0, 0, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 0, 0, 0.05) 0%, transparent 50%),
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 0, 0, 0.3) 2px, rgba(0, 0, 0, 0.3) 4px);
            min-height: 100vh;
            padding: 20px;
            color: var(--text-primary);
            transition: background 0.3s ease, color 0.3s ease;
        }
        
        .nav-bar {
            max-width: 1400px;
            margin: 0 auto 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: var(--container-bg);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(139, 0, 0, 0.5);
        }
        
        .nav-bar h1 {
            font-family: 'Orbitron', sans-serif;
            color: var(--accent-red);
            font-size: 1.5em;
            margin: 0;
        }
        
        .nav-buttons {
            display: flex;
            gap: 10px;
        }
        
        .nav-btn {
            padding: 10px 20px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 5px;
            color: var(--text-primary);
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 0.9em;
            text-transform: uppercase;
            text-decoration: none;
            transition: all 0.3s ease;
        }
        
        .nav-btn:hover {
            background: var(--bg-secondary);
            border-color: var(--accent-red);
            transform: translateY(-2px);
        }
        
        .fixed-back-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            padding: 10px 20px;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 5px;
            color: var(--text-primary);
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 0.9em;
            text-transform: uppercase;
            text-decoration: none;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        .fixed-back-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--accent-red);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        .dashboard-container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: var(--container-bg);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 0 20px rgba(139, 0, 0, 0.3);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 30px rgba(139, 0, 0, 0.5);
        }
        
        .stat-card h3 {
            font-family: 'Orbitron', sans-serif;
            color: var(--accent-red);
            font-size: 0.9em;
            margin-bottom: 10px;
            text-transform: uppercase;
        }
        
        .stat-card .value {
            font-size: 2.5em;
            font-weight: 900;
            color: var(--accent-red);
            margin: 10px 0;
        }
        
        .stat-card .label {
            color: var(--text-secondary);
            font-size: 0.9em;
        }
        
        .chart-section {
            background: var(--container-bg);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 0 20px rgba(139, 0, 0, 0.3);
        }
        
        .chart-section h2 {
            font-family: 'Orbitron', sans-serif;
            color: var(--accent-red);
            font-size: 1.5em;
            margin-bottom: 20px;
            text-transform: uppercase;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 10px;
        }
        
        .chart-container {
            position: relative;
            height: 400px;
            margin-top: 20px;
        }
        
        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 30px;
        }
        
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 5px;
            display: flex;
            gap: 3px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        
        .theme-btn {
            padding: 10px 12px;
            background: transparent;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .theme-btn:hover {
            background: var(--bg-tertiary);
        }
        
        .theme-btn.active {
            background: var(--accent-red);
            color: #fff;
            box-shadow: 0 2px 8px rgba(255, 26, 26, 0.4);
        }
        
        .theme-btn-icon {
            font-size: 1.3em;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
            font-size: 1.2em;
        }
    </style>
</head>
<body>
    <div class="theme-toggle" id="themeToggle" title="Select theme">
        <button class="theme-btn" data-theme="dark" id="themeBtnDark" title="Dark">
            <span class="theme-btn-icon">üåô</span>
        </button>
        <button class="theme-btn" data-theme="light" id="themeBtnLight" title="Light">
            <span class="theme-btn-icon">‚òÄÔ∏è</span>
        </button>
        <button class="theme-btn" data-theme="colorblind" id="themeBtnColorblind" title="Colorblind">
            <span class="theme-btn-icon">üëÅÔ∏è</span>
        </button>
    </div>
    
    <a href="/" class="fixed-back-btn">‚Üê Back to Calculator</a>
    
    <div class="nav-bar" style="margin-top: 70px;">
        <h1>üìä Analytics Dashboard</h1>
    </div>
    
    <div class="dashboard-container">
        <!-- Key Statistics Cards -->
        <div class="stats-grid" id="statsGrid">
            <div class="stat-card">
                <h3>Total Survivors</h3>
                <div class="value" id="totalSurvivors">-</div>
                <div class="label">Records Analyzed</div>
            </div>
            <div class="stat-card">
                <h3>Total Escapes</h3>
                <div class="value" id="totalEscapes">-</div>
                <div class="label">Successful Escapes</div>
            </div>
            <div class="stat-card">
                <h3>Overall Escape Rate</h3>
                <div class="value" id="escapeRate">-</div>
                <div class="label">Percentage</div>
            </div>
            <div class="stat-card">
                <h3>Total Games</h3>
                <div class="value" id="totalGames">-</div>
                <div class="label">Matches Recorded</div>
            </div>
        </div>
        
        <!-- Charts Container -->
        <div id="chartsContainer" class="loading">Loading dashboard data...</div>
    </div>
    
    <script>
        // Helper function to convert hex to rgba - defined first for global access
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        // Store all chart instances for theme updates
        const chartInstances = [];
        
        // Theme toggle functionality
        const themeToggle = document.getElementById('themeToggle');
        const themeLabel = document.getElementById('themeLabel');
        const htmlElement = document.documentElement;
        
        // Theme configuration
        const themes = ['dark', 'light', 'colorblind'];
        const themeIcons = { 'dark': 'üåô', 'light': '‚òÄÔ∏è', 'colorblind': 'üëÅÔ∏è' };
        const themeLabels = { 'dark': 'Dark', 'light': 'Light', 'colorblind': 'Colorblind' };
        
        const themeButtons = {
            'dark': document.getElementById('themeBtnDark'),
            'light': document.getElementById('themeBtnLight'),
            'colorblind': document.getElementById('themeBtnColorblind')
        };
        
        function updateThemeButtons(activeTheme) {
            Object.keys(themeButtons).forEach(theme => {
                if (themeButtons[theme]) {
                    if (theme === activeTheme) {
                        themeButtons[theme].classList.add('active');
                    } else {
                        themeButtons[theme].classList.remove('active');
                    }
                }
            });
        }
        
        const savedTheme = localStorage.getItem('theme') || 'dark';
        if (themes.includes(savedTheme)) {
            htmlElement.setAttribute('data-theme', savedTheme);
            updateThemeButtons(savedTheme);
        }
        
        // Function to update chart colors when theme changes
        function updateChartColors() {
            // Force a reflow to ensure CSS variables are updated
            void document.documentElement.offsetHeight;
            
            const root = getComputedStyle(document.documentElement);
            let textPrimary = root.getPropertyValue('--text-primary').trim();
            let textSecondary = root.getPropertyValue('--text-secondary').trim();
            let bgSecondary = root.getPropertyValue('--bg-secondary').trim();
            let borderColor = root.getPropertyValue('--border-color').trim();
            let accentRed = root.getPropertyValue('--accent-red').trim();
            let successColor = root.getPropertyValue('--color-success').trim();
            let failureColor = root.getPropertyValue('--color-failure').trim();
            
            // Fallback values if CSS variables aren't available
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
            if (!textPrimary || textPrimary === '') {
                textPrimary = currentTheme === 'light' ? '#1a1a1a' : '#e0e0e0';
            }
            if (!textSecondary || textSecondary === '') {
                textSecondary = currentTheme === 'light' ? '#555' : '#aaa';
            }
            if (!bgSecondary || bgSecondary === '') {
                bgSecondary = currentTheme === 'light' ? '#ffffff' : '#1a1a1a';
            }
            if (!borderColor || borderColor === '') {
                borderColor = currentTheme === 'light' ? '#ccc' : (currentTheme === 'colorblind' ? '#663300' : '#3a0000');
            }
            if (!accentRed || accentRed === '') {
                accentRed = currentTheme === 'colorblind' ? '#ff9933' : (currentTheme === 'light' ? '#d32f2f' : '#ff1a1a');
            }
            if (!successColor || successColor === '') {
                successColor = currentTheme === 'colorblind' ? '#4da6ff' : '#4dff4d';
            }
            if (!failureColor || failureColor === '') {
                failureColor = currentTheme === 'colorblind' ? '#ff9933' : '#ff6666';
            }
            
            const gridColor = root.getPropertyValue('--bg-primary').trim() === '#0a0a0a' 
                ? 'rgba(255, 255, 255, 0.1)' 
                : 'rgba(0, 0, 0, 0.1)';
            
            // Update all chart instances
            chartInstances.forEach(chart => {
                if (chart && typeof chart.update === 'function') {
                    try {
                        // Update dataset colors
                        if (chart.data && chart.data.datasets) {
                            chart.data.datasets.forEach((dataset, datasetIndex) => {
                                // Check if this is an escape rate chart (has array of colors)
                                if (Array.isArray(dataset.backgroundColor)) {
                                    // This is an escape rate chart - update colors based on values
                                    const values = dataset.data;
                                    dataset.backgroundColor = values.map((v, i) => {
                                        if (v === null || v === 0) return null;
                                        return v >= 50 ? hexToRgba(successColor, 0.6) : hexToRgba(failureColor, 0.6);
                                    });
                                    dataset.borderColor = values.map((v, i) => {
                                        if (v === null || v === 0) return null;
                                        return v >= 50 ? successColor : failureColor;
                                    });
                                } else {
                                    // Single color dataset - update based on chart type
                                    const label = dataset.label || '';
                                    const canvasId = chart.canvas && chart.canvas.id ? chart.canvas.id : '';
                                    
                                    // Check chart type first for better identification
                                    if (chart.type === 'bar' && label === 'Count') {
                                        // Feature distribution charts - backgroundColor must be a single string for bar charts
                                        // Delete and recreate the property to force Chart.js to recognize the change
                                        delete dataset.backgroundColor;
                                        delete dataset.borderColor;
                                        dataset.backgroundColor = hexToRgba(accentRed, 0.6);
                                        dataset.borderColor = accentRed;
                                        // Ensure borderWidth is set
                                        if (!dataset.borderWidth) {
                                            dataset.borderWidth = 2;
                                        }
                                    } else if (chart.type === 'line' && label === 'Count') {
                                        // This is a BP distribution chart - check canvas ID to determine which one
                                        if (canvasId.includes('killer')) {
                                            // Killer BP distribution - delete and recreate to force Chart.js to recognize the change
                                            delete dataset.backgroundColor;
                                            delete dataset.borderColor;
                                            dataset.backgroundColor = hexToRgba(failureColor, 0.2);
                                            dataset.borderColor = failureColor;
                                            dataset.pointBackgroundColor = failureColor;
                                            dataset.pointBorderColor = failureColor;
                                        } else if (canvasId.includes('survivor')) {
                                            // Survivor BP distribution - always use blue
                                            const survivorBlue = '#4da6ff';
                                            delete dataset.backgroundColor;
                                            delete dataset.borderColor;
                                            dataset.backgroundColor = hexToRgba(survivorBlue, 0.2);
                                            dataset.borderColor = survivorBlue;
                                            dataset.pointBackgroundColor = survivorBlue;
                                            dataset.pointBorderColor = survivorBlue;
                                        }
                                    } else if (label.includes('Killer BP')) {
                                        // Comparison chart killer dataset
                                        delete dataset.backgroundColor;
                                        delete dataset.borderColor;
                                        dataset.backgroundColor = hexToRgba(failureColor, 0.2);
                                        dataset.borderColor = failureColor;
                                        dataset.pointBackgroundColor = failureColor;
                                        dataset.pointBorderColor = failureColor;
                                    } else if (label.includes('Survivor BP')) {
                                        // Comparison chart survivor dataset - always use blue
                                        const survivorBlue = '#4da6ff';
                                        delete dataset.backgroundColor;
                                        delete dataset.borderColor;
                                        dataset.backgroundColor = hexToRgba(survivorBlue, 0.2);
                                        dataset.borderColor = survivorBlue;
                                        dataset.pointBackgroundColor = survivorBlue;
                                        dataset.pointBorderColor = survivorBlue;
                                    }
                                }
                            });
                        }
                        
                        // Update scales
                        if (chart.options && chart.options.scales) {
                            if (chart.options.scales.x) {
                                if (chart.options.scales.x.ticks) {
                                    chart.options.scales.x.ticks.color = textPrimary;
                                }
                                if (chart.options.scales.x.grid) {
                                    chart.options.scales.x.grid.color = gridColor;
                                }
                            }
                            if (chart.options.scales.y) {
                                if (chart.options.scales.y.ticks) {
                                    chart.options.scales.y.ticks.color = textPrimary;
                                    // Preserve callback if it exists (for escape rate charts with % formatting)
                                    if (chart.options.scales.y.ticks.callback) {
                                        const callback = chart.options.scales.y.ticks.callback;
                                        chart.options.scales.y.ticks.callback = callback;
                                    }
                                }
                                if (chart.options.scales.y.grid) {
                                    chart.options.scales.y.grid.color = gridColor;
                                }
                            }
                        }
                        
                        // Update plugins
                        if (chart.options && chart.options.plugins) {
                            if (chart.options.plugins.legend && chart.options.plugins.legend.labels) {
                                if (typeof chart.options.plugins.legend.labels.color === 'function') {
                                    // Keep the function but it will use updated CSS variables
                                } else {
                                    chart.options.plugins.legend.labels.color = textPrimary;
                                }
                            }
                            if (chart.options.plugins.tooltip) {
                                if (chart.options.plugins.tooltip.titleColor !== undefined) {
                                    chart.options.plugins.tooltip.titleColor = textPrimary;
                                }
                                if (chart.options.plugins.tooltip.bodyColor !== undefined) {
                                    chart.options.plugins.tooltip.bodyColor = textPrimary;
                                }
                                if (chart.options.plugins.tooltip.backgroundColor !== undefined) {
                                    chart.options.plugins.tooltip.backgroundColor = bgSecondary;
                                }
                                if (chart.options.plugins.tooltip.borderColor !== undefined) {
                                    chart.options.plugins.tooltip.borderColor = borderColor;
                                }
                            }
                        }
                        
                        // Force Chart.js to recognize all changes by updating the chart
                        // Use 'none' mode to avoid animation, but ensure all properties are set first
                        chart.update('none');
                        
                        // Force Chart.js to completely re-render by updating again after a short delay
                        // This ensures all color changes are properly applied
                        setTimeout(() => {
                            if (chart && typeof chart.update === 'function') {
                                // Force a full update to ensure colors are applied
                                chart.update('none');
                            }
                        }, 50);
                    } catch (error) {
                        console.error('Error updating chart colors:', error);
                    }
                }
            });
        }
        
        // Add click handlers to theme buttons
        Object.keys(themeButtons).forEach(theme => {
            if (themeButtons[theme]) {
                themeButtons[theme].addEventListener('click', () => {
                    htmlElement.setAttribute('data-theme', theme);
                    localStorage.setItem('theme', theme);
                    updateThemeButtons(theme);
                    
                    // Force DOM refresh by reloading dashboard data
                    // This ensures all colors are correctly rendered for the selected mode
                    const chartsContainer = document.getElementById('chartsContainer');
                    if (chartsContainer) {
                        chartsContainer.innerHTML = '<div class="loading">Updating dashboard...</div>';
                    }
                    
                    // Clear all existing chart instances
                    chartInstances.forEach(chart => {
                        if (chart && typeof chart.destroy === 'function') {
                            chart.destroy();
                        }
                    });
                    chartInstances.length = 0;
                    
                    // Reload dashboard with new theme
                    setTimeout(async () => {
                        await loadDashboard();
                        // Wait a bit longer to ensure all HTML is inserted and charts from loadDashboard are created
                        setTimeout(() => {
                            loadMapAreaScatter();
                            loadMatchOutcomes();
                        }, 800);
                    }, 150);
                });
            }
        });
        
        // Load and display statistics
        async function loadDashboard() {
            try {
                const response = await fetch('/statistics', {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' }
                });
                const data = await response.json();
                
                if (response.ok) {
                    displayDashboard(data);
                    // Return a promise that resolves after a short delay to ensure HTML is inserted
                    return new Promise(resolve => setTimeout(resolve, 100));
                } else {
                    throw new Error(data.error || 'Failed to load dashboard data');
                }
            } catch (error) {
                document.getElementById('chartsContainer').innerHTML = 
                    `<div style="color: var(--color-failure); padding: 20px; text-align: center;">Error: ${error.message}</div>`;
                return Promise.resolve();
            }
        }
        
        function displayDashboard(stats) {
            // Update stat cards
            const totalSurvivors = stats.total_games;
            const totalGames = Math.floor(stats.total_games / 4);
            document.getElementById('totalSurvivors').textContent = totalSurvivors.toLocaleString();
            document.getElementById('totalEscapes').textContent = stats.total_escapes.toLocaleString();
            document.getElementById('escapeRate').textContent = stats.overall_escape_rate.toFixed(1) + '%';
            document.getElementById('totalGames').textContent = totalGames.toLocaleString();
            
            // Get computed CSS variable values for theme-aware chart colors
            const root = getComputedStyle(document.documentElement);
            let textPrimary = root.getPropertyValue('--text-primary').trim();
            let textSecondary = root.getPropertyValue('--text-secondary').trim();
            let bgSecondary = root.getPropertyValue('--bg-secondary').trim();
            let borderColor = root.getPropertyValue('--border-color').trim();
            
            // Fallback values if CSS variables aren't available
            if (!textPrimary || textPrimary === '') {
                textPrimary = document.documentElement.getAttribute('data-theme') === 'light' ? '#1a1a1a' : '#e0e0e0';
            }
            if (!textSecondary || textSecondary === '') {
                textSecondary = document.documentElement.getAttribute('data-theme') === 'light' ? '#555' : '#aaa';
            }
            if (!bgSecondary || bgSecondary === '') {
                bgSecondary = document.documentElement.getAttribute('data-theme') === 'light' ? '#ffffff' : '#1a1a1a';
            }
            if (!borderColor || borderColor === '') {
                borderColor = document.documentElement.getAttribute('data-theme') === 'light' ? '#ccc' : '#3a0000';
            }
            
            const gridColor = root.getPropertyValue('--bg-primary').trim() === '#0a0a0a' 
                ? 'rgba(255, 255, 255, 0.1)' 
                : 'rgba(0, 0, 0, 0.1)';
            
            let html = '<div>';
            
            // Match Outcomes section (at the top)
            html += '<div style="margin-top: 30px; margin-bottom: 20px; padding: 15px; background: var(--bg-secondary); border-left: 4px solid var(--accent-red); border-radius: 5px;">';
            html += '<h2 style="color: var(--accent-red); margin: 0; font-size: 1.8em; font-weight: bold; text-transform: uppercase; letter-spacing: 1px;">Match Outcomes</h2>';
            html += '<p style="color: var(--text-secondary); margin-top: 10px; font-size: 0.9em;">Distribution of match results (grouped by batches of 4 survivors)</p>';
            html += '</div>';
            html += '<div style="background: var(--bg-tertiary); padding: 15px; border-radius: 5px; margin-bottom: 20px;">';
            html += `<div id="matchOutcomesNote" style="margin-bottom: 10px; color: var(--text-secondary); font-size: 0.9em;"></div>`;
            html += `<div style="position: relative; height: 400px;"><canvas id="chart-match-outcomes"></canvas></div>`;
            html += `</div>`;
            
            // Additional match outcomes breakdowns (under same section)
            html += '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin-bottom: 20px; margin-top: 20px;">';
            html += '<div style="background: var(--bg-tertiary); padding: 15px; border-radius: 5px;">';
            html += `<strong style="color: var(--accent-red); font-size: 1.1em;">By Number of Medkits</strong>`;
            html += `<div style="position: relative; height: 400px; margin-top: 15px;"><canvas id="chart-match-medkits"></canvas></div>`;
            html += `</div>`;
            html += '<div style="background: var(--bg-tertiary); padding: 15px; border-radius: 5px;">';
            html += `<strong style="color: var(--accent-red); font-size: 1.1em;">By Number of Flashlights</strong>`;
            html += `<div style="position: relative; height: 400px; margin-top: 15px;"><canvas id="chart-match-flashlights"></canvas></div>`;
            html += `</div>`;
            html += '</div>';
            html += '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin-bottom: 20px;">';
            html += '<div style="background: var(--bg-tertiary); padding: 15px; border-radius: 5px;">';
            html += `<strong style="color: var(--accent-red); font-size: 1.1em;">By Number of Survivors with Second Chance Perks</strong>`;
            html += `<div style="position: relative; height: 400px; margin-top: 15px;"><canvas id="chart-match-second-chance"></canvas></div>`;
            html += `</div>`;
            html += '<div style="background: var(--bg-tertiary); padding: 15px; border-radius: 5px;">';
            html += `<strong style="color: var(--accent-red); font-size: 1.1em;">By Total Chase Perks</strong>`;
            html += `<div style="position: relative; height: 400px; margin-top: 15px;"><canvas id="chart-match-chase-perks"></canvas></div>`;
            html += `</div>`;
            html += '</div>';
            
            // Feature distributions with charts
            if (stats.feature_stats) {
                html += '<div style="margin-top: 30px; margin-bottom: 20px; padding: 15px; background: var(--bg-secondary); border-left: 4px solid var(--accent-red); border-radius: 5px;">';
                html += '<h2 style="color: var(--accent-red); margin: 0; font-size: 1.8em; font-weight: bold; text-transform: uppercase; letter-spacing: 1px;">Feature Distributions</h2>';
                html += '</div>';
                
                // Define feature order matching form order
                const featureDisplayOrder = [
                    'Survivor Gender',
                    'Steam Player',
                    'Anonymous Mode',
                    'Prestige',
                    'Item',
                    'Powerful Add-ons',
                    'Map Type',
                    'Map Area',
                    'Exhaustion Perk',
                    'Chase Perks',
                    'Decisive Strike',
                    'Unbreakable',
                    'Off the Record',
                    'Adrenaline',
                    'Survivor BP',
                    'Killer BP'
                ];
                
                // Sort features by display order
                const sortedFeatures = Object.entries(stats.feature_stats).sort(([featureA], [featureB]) => {
                    const indexA = featureDisplayOrder.indexOf(featureA);
                    const indexB = featureDisplayOrder.indexOf(featureB);
                    // If not found in order, put at end
                    if (indexA === -1 && indexB === -1) return featureA.localeCompare(featureB);
                    if (indexA === -1) return 1;
                    if (indexB === -1) return -1;
                    return indexA - indexB;
                });
                
                html += '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin-bottom: 20px;">';
                let chartIndex = 0;
                sortedFeatures.forEach(([feature, data]) => {
                    if (data.distribution && Object.keys(data.distribution).length > 0) {
                        html += `<div style="background: var(--bg-tertiary); padding: 15px; border-radius: 5px;">`;
                        const accentColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-red').trim();
                        html += `<strong style="color: ${accentColor}; font-size: 1.1em;">${feature}</strong>`;
                        html += `<div style="position: relative; height: 300px; margin-top: 15px;"><canvas id="chart-dist-${chartIndex}"></canvas></div>`;
                        html += `</div>`;
                        chartIndex++;
                    }
                });
                html += '</div>';
            }
            
            // Escape rates by feature with charts
            if (stats.escape_rates) {
                html += '<div style="margin-top: 40px; margin-bottom: 20px; padding: 15px; background: var(--bg-secondary); border-left: 4px solid var(--accent-red); border-radius: 5px;">';
                html += '<h2 style="color: var(--accent-red); margin: 0; font-size: 1.8em; font-weight: bold; text-transform: uppercase; letter-spacing: 1px;">Escape Rates by Feature</h2>';
                html += '</div>';
                
                // Define feature order matching form order (same as above)
                const escapeRateFeatureOrder = [
                    'Survivor Gender',
                    'Steam Player',
                    'Anonymous Mode',
                    'Prestige',
                    'Item',
                    'Powerful Add-ons',
                    'Map Type',
                    'Map Area',
                    'Exhaustion Perk',
                    'Chase Perks',
                    'Decisive Strike',
                    'Unbreakable',
                    'Off the Record',
                    'Adrenaline',
                    'Survivor BP',
                    'Killer BP'
                ];
                
                // Sort features by display order
                const sortedEscapeRates = Object.entries(stats.escape_rates).sort(([featureA], [featureB]) => {
                    const indexA = escapeRateFeatureOrder.indexOf(featureA);
                    const indexB = escapeRateFeatureOrder.indexOf(featureB);
                    // If not found in order, put at end
                    if (indexA === -1 && indexB === -1) return featureA.localeCompare(featureB);
                    if (indexA === -1) return 1;
                    if (indexB === -1) return -1;
                    return indexA - indexB;
                });
                
                html += '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin-bottom: 20px;">';
                let escapeChartIndex = 0;
                sortedEscapeRates.forEach(([feature, rates]) => {
                    if (rates && Object.keys(rates).length > 0) {
                        html += `<div style="background: var(--bg-tertiary); padding: 15px; border-radius: 5px;">`;
                        const accentColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-red').trim();
                        html += `<strong style="color: ${accentColor}; font-size: 1.1em;">${feature}</strong>`;
                        html += `<div style="position: relative; height: 300px; margin-top: 15px;"><canvas id="chart-escape-${escapeChartIndex}"></canvas></div>`;
                        html += `</div>`;
                        escapeChartIndex++;
                    }
                });
                html += '</div>';
                
                // Add Map Area scatter plot at the end (full width)
                html += '<div style="background: var(--bg-tertiary); padding: 15px; border-radius: 5px; margin-top: 20px;">';
                const accentColorMap = getComputedStyle(document.documentElement).getPropertyValue('--accent-red').trim();
                html += `<strong style="color: ${accentColorMap}; font-size: 1.1em;">Map Area (Scatter Plot)</strong>`;
                html += `<div id="mapAreaScatterNote" style="margin-top: 10px; color: var(--text-secondary); font-size: 0.9em;"></div>`;
                html += `<div style="position: relative; height: 400px; margin-top: 15px;"><canvas id="scatter-map-area"></canvas></div>`;
                html += `</div>`;
            }
            
            // Bloodpoints distribution graphs
            if (stats.bloodpoints_stats) {
                html += '<div style="margin-top: 40px; margin-bottom: 20px; padding: 15px; background: var(--bg-secondary); border-left: 4px solid var(--accent-red); border-radius: 5px;">';
                html += '<h2 style="color: var(--accent-red); margin: 0; font-size: 1.8em; font-weight: bold; text-transform: uppercase; letter-spacing: 1px;">Match Bloodpoints Distribution</h2>';
                html += '</div>';
                
                // Individual graphs in 2-column grid
                html += '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin-bottom: 20px;">';
                if (stats.bloodpoints_stats.survivor_bp) {
                    // Survivor BP title should always be blue, not green
                    const survivorBlueColor = '#4da6ff';
                    html += '<div style="background: var(--bg-tertiary); padding: 15px; border-radius: 5px;">';
                    html += `<strong style="color: ${survivorBlueColor}; font-size: 1.1em;">Survivor Match Bloodpoints Distribution</strong>`;
                    const survivorStats = stats.bloodpoints_stats.survivor_bp;
                    html += `<div style="margin-top: 10px; color: var(--text-secondary); font-size: 0.9em;">`;
                    html += `Mean: ${survivorStats.mean.toFixed(0)} | Median: ${survivorStats.median.toFixed(0)} | Range: ${survivorStats.min.toFixed(0)} - ${survivorStats.max.toFixed(0)}`;
                    html += `</div>`;
                    html += `<div style="position: relative; height: 300px; margin-top: 15px;"><canvas id="chart-bp-survivor"></canvas></div>`;
                    html += `</div>`;
                }
                
                if (stats.bloodpoints_stats.killer_bp) {
                    const rootBPKiller = getComputedStyle(document.documentElement);
                    const failureColorBPKiller = rootBPKiller.getPropertyValue('--color-failure').trim();
                    html += '<div style="background: var(--bg-tertiary); padding: 15px; border-radius: 5px;">';
                    html += `<strong style="color: ${failureColorBPKiller}; font-size: 1.1em;">Killer Match Bloodpoints Distribution</strong>`;
                    const killerStats = stats.bloodpoints_stats.killer_bp;
                    html += `<div style="margin-top: 10px; color: var(--text-secondary); font-size: 0.9em;">`;
                    html += `Mean: ${killerStats.mean.toFixed(0)} | Median: ${killerStats.median.toFixed(0)} | Range: ${killerStats.min.toFixed(0)} - ${killerStats.max.toFixed(0)}`;
                    html += `</div>`;
                    html += `<div style="position: relative; height: 300px; margin-top: 15px;"><canvas id="chart-bp-killer"></canvas></div>`;
                    html += `</div>`;
                }
                html += '</div>';
                
                // Comparison graph (overlayed) - full width
                if (stats.bloodpoints_stats.survivor_bp && stats.bloodpoints_stats.killer_bp) {
                    const rootCompTitle = getComputedStyle(document.documentElement);
                    const accentColorComp = rootCompTitle.getPropertyValue('--accent-red').trim();
                    html += '<div style="background: var(--bg-tertiary); padding: 15px; margin-bottom: 20px; border-radius: 5px;">';
                    html += `<strong style="color: ${accentColorComp}; font-size: 1.1em;">Survivor vs Killer Match Bloodpoints Comparison</strong>`;
                    html += `<div style="position: relative; height: 300px; margin-top: 15px;"><canvas id="chart-bp-comparison"></canvas></div>`;
                    html += `</div>`;
                }
            }
            
            html += '</div>';
            document.getElementById('chartsContainer').innerHTML = html;
            
            // Create distribution charts
            if (stats.feature_stats) {
                // Use same feature order as above
                const featureDisplayOrderForCharts = [
                    'Survivor Gender',
                    'Steam Player',
                    'Anonymous Mode',
                    'Prestige',
                    'Item',
                    'Powerful Add-ons',
                    'Map Type',
                    'Map Area',
                    'Exhaustion Perk',
                    'Chase Perks',
                    'Decisive Strike',
                    'Unbreakable',
                    'Off the Record',
                    'Adrenaline',
                    'Survivor BP',
                    'Killer BP'
                ];
                
                // Sort features by display order
                const sortedFeaturesForCharts = Object.entries(stats.feature_stats).sort(([featureA], [featureB]) => {
                    const indexA = featureDisplayOrderForCharts.indexOf(featureA);
                    const indexB = featureDisplayOrderForCharts.indexOf(featureB);
                    // If not found in order, put at end
                    if (indexA === -1 && indexB === -1) return featureA.localeCompare(featureB);
                    if (indexA === -1) return 1;
                    if (indexB === -1) return -1;
                    return indexA - indexB;
                });
                
                let chartIndex = 0;
                sortedFeaturesForCharts.forEach(([feature, data]) => {
                    if (data.distribution && Object.keys(data.distribution).length > 0) {
                        const ctx = document.getElementById(`chart-dist-${chartIndex}`);
                        if (ctx) {
                            let labels = Object.keys(data.distribution);
                            let values = Object.values(data.distribution);
                            
                            // Sort prestige labels numerically (individual values like "0", "1", "2", etc.)
                            let prestigeMultiplesOf5 = null;
                            if (feature === 'Prestige') {
                                const labelValuePairs = labels.map((label, i) => [label, values[i]]);
                                labelValuePairs.sort((a, b) => {
                                    return parseInt(a[0]) - parseInt(b[0]);
                                });
                                
                                // Create a map of existing values
                                const existingData = new Map();
                                labelValuePairs.forEach(([label, value]) => {
                                    existingData.set(parseInt(label), value);
                                });
                                
                                // Get the range
                                const minPrestige = parseInt(labelValuePairs[0][0]);
                                const maxPrestige = parseInt(labelValuePairs[labelValuePairs.length - 1][0]);
                                
                                // Create complete labels and values arrays with all values from min to max
                                const completeLabels = [];
                                const completeValues = [];
                                for (let i = minPrestige; i <= maxPrestige; i++) {
                                    completeLabels.push(i.toString());
                                    completeValues.push(existingData.get(i) || 0);
                                }
                                
                                labels = completeLabels;
                                values = completeValues;
                                
                                // Calculate all multiples of 5 in the range (0 to 100)
                                prestigeMultiplesOf5 = new Set();
                                for (let i = 0; i <= 100; i += 5) {
                                    if (i >= minPrestige && i <= maxPrestige) {
                                        prestigeMultiplesOf5.add(i);
                                    }
                                }
                            }
                            
                            const percentages = values.map(v => ((v / data.total) * 100).toFixed(1));
                            
                            // Set data to null for 0 values so bars aren't drawn, but keep labels for tooltips
                            const displayValues = values.map(v => v === 0 ? null : v);
                            
                            // Only rotate labels for Exhaustion Perk feature
                            const shouldRotateLabels = feature === 'Exhaustion Perk';
                            
                            // Get theme colors for feature distribution charts
                            const root = getComputedStyle(document.documentElement);
                            const accentRed = root.getPropertyValue('--accent-red').trim();
                            
                            const chart = new Chart(ctx, {
                                type: 'bar',
                                data: {
                                    labels: labels,
                                    datasets: [{
                                        label: 'Count',
                                        data: displayValues,
                                        backgroundColor: hexToRgba(accentRed, 0.6),
                                        borderColor: accentRed,
                                        borderWidth: 2,
                                        minBarLength: 5
                                    }]
                                },
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    interaction: {
                                        mode: 'index',
                                        intersect: false
                                    },
                                    plugins: {
                                        legend: {
                                            display: false,
                                            labels: {
                                                color: textPrimary
                                            }
                                        },
                                        tooltip: {
                                            callbacks: {
                                                label: function(context) {
                                                    const index = context.dataIndex;
                                                    const originalValue = values[index];
                                                    const percentage = percentages[index];
                                                    // Show 0 even if bar isn't displayed
                                                    if (originalValue === 0 || context.parsed.y === null) {
                                                        return `0 (${percentage}%)`;
                                                    }
                                                    return `${context.parsed.y} (${percentage}%)`;
                                                }
                                            },
                                            titleColor: textPrimary,
                                            bodyColor: textPrimary,
                                            backgroundColor: bgSecondary,
                                            borderColor: borderColor,
                                            borderWidth: 1
                                        }
                                    },
                                    scales: {
                                        y: {
                                            beginAtZero: true,
                                            ticks: {
                                                color: textPrimary
                                            },
                                            grid: {
                                                color: gridColor
                                            }
                                        },
                                        x: {
                                            ticks: {
                                                color: textPrimary,
                                                maxRotation: shouldRotateLabels ? 45 : 0,
                                                minRotation: shouldRotateLabels ? 45 : 0,
                                                // For prestige, disable auto-skip and show all multiples of 5
                                                ...(feature === 'Prestige' ? {
                                                    autoSkip: false,
                                                    maxTicksLimit: 1000,
                                                    callback: function(value, index) {
                                                        if (index >= labels.length) return '';
                                                        const labelValue = parseInt(labels[index]);
                                                        // Show label if it's a multiple of 5 in the range
                                                        return prestigeMultiplesOf5 && prestigeMultiplesOf5.has(labelValue) ? labelValue : '';
                                                    }
                                                } : {}),
                                                // For Item, disable auto-skip to show all items and don't rotate labels
                                                ...(feature === 'Item' ? {
                                                    autoSkip: false,
                                                    maxTicksLimit: 1000,
                                                    maxRotation: 0,
                                                    minRotation: 0
                                                } : {})
                                            },
                                            grid: {
                                                color: gridColor
                                            }
                                        }
                                    }
                                }
                            });
                            chartInstances.push(chart);
                        }
                        chartIndex++;
                    }
                });
            }
            
            // Create escape rate charts
            if (stats.escape_rates) {
                // Use same feature order as above
                const escapeRateFeatureOrderForCharts = [
                    'Survivor Gender',
                    'Steam Player',
                    'Anonymous Mode',
                    'Prestige',
                    'Item',
                    'Powerful Add-ons',
                    'Map Type',
                    'Map Area',
                    'Exhaustion Perk',
                    'Chase Perks',
                    'Decisive Strike',
                    'Unbreakable',
                    'Off the Record',
                    'Adrenaline',
                    'Survivor BP',
                    'Killer BP'
                ];
                
                // Sort features by display order
                const sortedEscapeRatesForCharts = Object.entries(stats.escape_rates).sort(([featureA], [featureB]) => {
                    const indexA = escapeRateFeatureOrderForCharts.indexOf(featureA);
                    const indexB = escapeRateFeatureOrderForCharts.indexOf(featureB);
                    // If not found in order, put at end
                    if (indexA === -1 && indexB === -1) return featureA.localeCompare(featureB);
                    if (indexA === -1) return 1;
                    if (indexB === -1) return -1;
                    return indexA - indexB;
                });
                
                let escapeChartIndex = 0;
                sortedEscapeRatesForCharts.forEach(([feature, rates]) => {
                    if (rates && Object.keys(rates).length > 0) {
                        const ctx = document.getElementById(`chart-escape-${escapeChartIndex}`);
                        if (ctx) {
                            let labels = Object.keys(rates);
                            let values = Object.values(rates);
                            
                            // Sort prestige labels numerically (individual values like "0", "1", "2", etc.)
                            let prestigeMultiplesOf5Escape = null;
                            if (feature === 'Prestige') {
                                const labelValuePairs = labels.map((label, i) => [label, values[i]]);
                                labelValuePairs.sort((a, b) => {
                                    return parseInt(a[0]) - parseInt(b[0]);
                                });
                                
                                // Create a map of existing values
                                const existingData = new Map();
                                labelValuePairs.forEach(([label, value]) => {
                                    existingData.set(parseInt(label), value);
                                });
                                
                                // Get the range
                                const minPrestige = parseInt(labelValuePairs[0][0]);
                                const maxPrestige = parseInt(labelValuePairs[labelValuePairs.length - 1][0]);
                                
                                // Create complete labels and values arrays with all values from min to max
                                const completeLabels = [];
                                const completeValues = [];
                                for (let i = minPrestige; i <= maxPrestige; i++) {
                                    completeLabels.push(i.toString());
                                    completeValues.push(existingData.get(i) || 0);
                                }
                                
                                labels = completeLabels;
                                values = completeValues;
                                
                                // Calculate all multiples of 5 in the range (0 to 100)
                                prestigeMultiplesOf5Escape = new Set();
                                for (let i = 0; i <= 100; i += 5) {
                                    if (i >= minPrestige && i <= maxPrestige) {
                                        prestigeMultiplesOf5Escape.add(i);
                                    }
                                }
                            }
                            
                            // Get escape counts for this feature if available
                            let escapeCounts = stats.feature_stats && stats.feature_stats[feature] && stats.feature_stats[feature].escape_counts 
                                ? stats.feature_stats[feature].escape_counts 
                                : {};
                            
                            // For prestige, ensure escape counts exist for all labels (fill with 0 if missing)
                            if (feature === 'Prestige') {
                                const completeEscapeCounts = {};
                                labels.forEach(label => {
                                    completeEscapeCounts[label] = escapeCounts[label] || 0;
                                });
                                escapeCounts = completeEscapeCounts;
                            }
                            
                            // Get theme colors for escape rate charts
                            const root = getComputedStyle(document.documentElement);
                            const successColor = root.getPropertyValue('--color-success').trim();
                            const failureColor = root.getPropertyValue('--color-failure').trim();
                            
                            // Set data to null for 0 escape rates so bars aren't drawn, but keep labels for tooltips
                            const displayValues = values.map(v => v === 0 ? null : v);
                            const displayColors = values.map((v, i) => {
                                if (v === 0) return null;
                                // Use success color for >=50%, failure color for <50%
                                return v >= 50 ? hexToRgba(successColor, 0.6) : hexToRgba(failureColor, 0.6);
                            });
                            const displayBorderColors = values.map((v, i) => {
                                if (v === 0) return null;
                                // Use success color for >=50%, failure color for <50%
                                return v >= 50 ? successColor : failureColor;
                            });
                            
                            // Calculate nice even percentages for y-axis
                            const nonZeroValues = values.filter(v => v > 0);
                            let niceMax = 100;
                            let niceMin = 0;
                            
                            if (nonZeroValues.length > 0) {
                                const maxValue = Math.max(...nonZeroValues);
                                const minValue = Math.min(...nonZeroValues);
                                
                                // Round max to nearest even 10% and add 10% padding, but cap at 100%
                                niceMax = Math.ceil((maxValue + 10) / 10) * 10;
                                niceMax = Math.min(100, niceMax);
                                
                                // Round min to nearest even 10% and subtract 10% padding, but not below 0
                                niceMin = Math.floor((minValue - 10) / 10) * 10;
                                niceMin = Math.max(0, niceMin);
                            }
                            
                            const escapeChart = new Chart(ctx, {
                                type: 'bar',
                                data: {
                                    labels: labels,
                                    datasets: [{
                                        label: 'Escape Rate %',
                                        data: displayValues,
                                        backgroundColor: displayColors,
                                        borderColor: displayBorderColors,
                                        borderWidth: 2,
                                        minBarLength: 5
                                    }]
                                },
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    interaction: {
                                        mode: 'index',
                                        intersect: false
                                    },
                                    plugins: {
                                        legend: {
                                            display: false,
                                            labels: {
                                                color: textPrimary
                                            }
                                        },
                                        tooltip: {
                                            callbacks: {
                                                label: function(context) {
                                                    const index = context.dataIndex;
                                                    const label = labels[index];
                                                    const originalValue = values[index];
                                                    const escapeCount = escapeCounts[label];
                                                    
                                                    // Show 0% and 0 escapes even if bar isn't displayed
                                                    if (originalValue === 0 || context.parsed.y === null) {
                                                        const count = escapeCount !== undefined ? escapeCount : 0;
                                                        const escapeText = count === 1 ? 'escape' : 'escapes';
                                                        return `Escape Rate: 0.0% (${count} ${escapeText})`;
                                                    }
                                                    
                                                    if (escapeCount !== undefined) {
                                                        const escapeText = escapeCount === 1 ? 'escape' : 'escapes';
                                                        return `Escape Rate: ${context.parsed.y.toFixed(1)}% (${escapeCount} ${escapeText})`;
                                                    }
                                                    return `Escape Rate: ${context.parsed.y.toFixed(1)}%`;
                                                }
                                            },
                                            titleColor: textPrimary,
                                            bodyColor: textPrimary,
                                            backgroundColor: bgSecondary,
                                            borderColor: borderColor,
                                            borderWidth: 1
                                        }
                                    },
                                    scales: {
                                        y: {
                                            beginAtZero: false,
                                            min: niceMin,
                                            max: niceMax,
                                            ticks: {
                                                color: textPrimary,
                                                callback: function(value) {
                                                    return value.toFixed(1) + '%';
                                                }
                                            },
                                            grid: {
                                                color: gridColor
                                            }
                                        },
                                        x: {
                                            ticks: {
                                                color: textPrimary,
                                                // For prestige, disable auto-skip, show all multiples of 5, and don't rotate labels
                                                ...(feature === 'Prestige' ? {
                                                    autoSkip: false,
                                                    maxTicksLimit: 1000,
                                                    maxRotation: 0,
                                                    minRotation: 0,
                                                    callback: function(value, index) {
                                                        if (index >= labels.length) return '';
                                                        const labelValue = parseInt(labels[index]);
                                                        // Show label if it's a multiple of 5 in the range
                                                        return prestigeMultiplesOf5Escape && prestigeMultiplesOf5Escape.has(labelValue) ? labelValue : '';
                                                    }
                                                } : {}),
                                                // For Item, disable auto-skip to show all items and don't rotate labels
                                                ...(feature === 'Item' ? {
                                                    autoSkip: false,
                                                    maxTicksLimit: 1000,
                                                    maxRotation: 0,
                                                    minRotation: 0
                                                } : {})
                                            },
                                            grid: {
                                                color: gridColor
                                            }
                                        }
                                    }
                                }
                            });
                            chartInstances.push(escapeChart);
                        }
                        escapeChartIndex++;
                    }
                });
            }
            
            // Create bloodpoints distribution charts
            if (stats.bloodpoints_stats) {
                // Survivor BP chart
                if (stats.bloodpoints_stats.survivor_bp) {
                    const ctxSurvivor = document.getElementById('chart-bp-survivor');
                    if (ctxSurvivor) {
                        const survivorData = stats.bloodpoints_stats.survivor_bp;
                        const binSize = survivorData.bin_size || 5000;
                        
                        // Sort labels numerically and create marker labels (just the bin start values)
                        const sortedLabels = Object.keys(survivorData.distribution).sort((a, b) => parseInt(a) - parseInt(b));
                        const markerLabels = sortedLabels.map(label => {
                            const start = parseInt(label);
                            return start.toLocaleString();
                        });
                        const values = sortedLabels.map(label => survivorData.distribution[label]);
                        
                        // Survivor BP charts should always be blue
                        const survivorBlueColor = '#4da6ff';
                        
                        const survivorChart = new Chart(ctxSurvivor, {
                            type: 'line',
                            data: {
                                labels: markerLabels,
                                datasets: [{
                                    label: 'Count',
                                    data: values,
                                    backgroundColor: hexToRgba(survivorBlueColor, 0.2),
                                    borderColor: survivorBlueColor,
                                    borderWidth: 2,
                                    fill: true,
                                    tension: 0.4,
                                    pointRadius: 3,
                                    pointHoverRadius: 5,
                                    pointBackgroundColor: survivorBlueColor,
                                    pointBorderColor: survivorBlueColor
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                interaction: {
                                    mode: 'index',
                                    intersect: false
                                },
                                plugins: {
                                    legend: {
                                        display: false,
                                        labels: {
                                            color: textPrimary
                                        }
                                    },
                                    tooltip: {
                                        callbacks: {
                                            title: function(context) {
                                                const binStart = parseInt(sortedLabels[context[0].dataIndex]);
                                                const binEnd = binStart + binSize;
                                                return `${binStart.toLocaleString()} - ${binEnd.toLocaleString()} BP`;
                                            },
                                            label: function(context) {
                                                const percentage = survivorData.total > 0 ? ((context.parsed.y / survivorData.total) * 100).toFixed(1) : 0;
                                                return `${context.parsed.y} survivors (${percentage}%)`;
                                            }
                                        },
                                        titleColor: textPrimary,
                                        bodyColor: textPrimary,
                                        backgroundColor: bgSecondary,
                                        borderColor: borderColor,
                                        borderWidth: 1
                                    }
                                },
                                scales: {
                                    y: {
                                        beginAtZero: true,
                                        ticks: {
                                            color: textPrimary
                                        },
                                        grid: {
                                            color: gridColor
                                        }
                                    },
                                    x: {
                                        ticks: {
                                            color: textPrimary,
                                            maxRotation: 45,
                                            minRotation: 45
                                        },
                                        grid: {
                                            color: gridColor
                                        }
                                    }
                                }
                            }
                        });
                        chartInstances.push(survivorChart);
                    }
                }
                
                // Killer BP chart
                if (stats.bloodpoints_stats.killer_bp) {
                    const ctxKiller = document.getElementById('chart-bp-killer');
                    if (ctxKiller) {
                        const killerData = stats.bloodpoints_stats.killer_bp;
                        const binSize = killerData.bin_size || 5000;
                        
                        // Sort labels numerically and create marker labels (just the bin start values)
                        const sortedLabels = Object.keys(killerData.distribution).sort((a, b) => parseInt(a) - parseInt(b));
                        const markerLabels = sortedLabels.map(label => {
                            const start = parseInt(label);
                            return start.toLocaleString();
                        });
                        // Divide by 4 since each game has 4 survivors with the same killer BP
                        const values = sortedLabels.map(label => Math.round(killerData.distribution[label] / 4));
                        
                        // Get theme colors for killer BP chart
                        const rootKiller = getComputedStyle(document.documentElement);
                        const failureColorKiller = rootKiller.getPropertyValue('--color-failure').trim();
                        
                        const killerChart = new Chart(ctxKiller, {
                            type: 'line',
                            data: {
                                labels: markerLabels,
                                datasets: [{
                                    label: 'Count',
                                    data: values,
                                    backgroundColor: hexToRgba(failureColorKiller, 0.2),
                                    borderColor: failureColorKiller,
                                    borderWidth: 2,
                                    fill: true,
                                    tension: 0.4,
                                    pointRadius: 3,
                                    pointHoverRadius: 5,
                                    pointBackgroundColor: failureColorKiller,
                                    pointBorderColor: failureColorKiller
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                interaction: {
                                    mode: 'index',
                                    intersect: false
                                },
                                plugins: {
                                    legend: {
                                        display: false,
                                        labels: {
                                            color: textPrimary
                                        }
                                    },
                                    tooltip: {
                                        callbacks: {
                                            title: function(context) {
                                                const binStart = parseInt(sortedLabels[context[0].dataIndex]);
                                                const binEnd = binStart + binSize;
                                                return `${binStart.toLocaleString()} - ${binEnd.toLocaleString()} BP`;
                                            },
                                            label: function(context) {
                                                // Use adjusted total (divided by 4) for percentage calculation
                                                const adjustedTotal = Math.round(killerData.total / 4);
                                                const percentage = adjustedTotal > 0 ? ((context.parsed.y / adjustedTotal) * 100).toFixed(1) : 0;
                                                return `${context.parsed.y} games (${percentage}%)`;
                                            }
                                        },
                                        titleColor: textPrimary,
                                        bodyColor: textPrimary,
                                        backgroundColor: bgSecondary,
                                        borderColor: borderColor,
                                        borderWidth: 1
                                    }
                                },
                                scales: {
                                    y: {
                                        beginAtZero: true,
                                        ticks: {
                                            color: textPrimary
                                        },
                                        grid: {
                                            color: gridColor
                                        }
                                    },
                                    x: {
                                        ticks: {
                                            color: textPrimary,
                                            maxRotation: 45,
                                            minRotation: 45
                                        },
                                        grid: {
                                            color: gridColor
                                        }
                                    }
                                }
                            }
                        });
                        chartInstances.push(killerChart);
                    }
                }
                
                // Comparison chart (overlayed)
                if (stats.bloodpoints_stats.survivor_bp && stats.bloodpoints_stats.killer_bp) {
                    const ctxComparison = document.getElementById('chart-bp-comparison');
                    if (ctxComparison) {
                        const survivorData = stats.bloodpoints_stats.survivor_bp;
                        const killerData = stats.bloodpoints_stats.killer_bp;
                        const binSize = survivorData.bin_size || killerData.bin_size || 5000;
                        
                        // Get all unique bin labels from both distributions (they're now just numbers)
                        const allLabels = new Set([
                            ...Object.keys(survivorData.distribution),
                            ...Object.keys(killerData.distribution)
                        ]);
                        const sortedLabels = Array.from(allLabels).sort((a, b) => parseInt(a) - parseInt(b));
                        
                        // Create marker labels for display (just the bin start values)
                        const markerLabels = sortedLabels.map(label => {
                            const start = parseInt(label);
                            return start.toLocaleString();
                        });
                        
                        // Convert to percentages for comparison
                        const survivorTotal = survivorData.total;
                        const killerTotal = Math.round(killerData.total / 4); // Divide by 4 for actual game count
                        
                        const survivorValues = sortedLabels.map(label => {
                            const count = survivorData.distribution[label] || 0;
                            return survivorTotal > 0 ? (count / survivorTotal) * 100 : 0;
                        });
                        const killerValues = sortedLabels.map(label => {
                            const count = killerData.distribution[label] || 0;
                            const gameCount = Math.round(count / 4); // Divide by 4 for actual game count
                            return killerTotal > 0 ? (gameCount / killerTotal) * 100 : 0;
                        });
                        
                        // Get theme colors for comparison chart
                        // Survivor BP should always be blue, killer BP uses theme color
                        const rootComp = getComputedStyle(document.documentElement);
                        const survivorBlueComp = '#4da6ff';
                        const failureColorComp = rootComp.getPropertyValue('--color-failure').trim();
                        
                        const comparisonChart = new Chart(ctxComparison, {
                            type: 'line',
                            data: {
                                labels: markerLabels,
                                datasets: [
                                    {
                                        label: 'Survivor BP',
                                        data: survivorValues,
                                        backgroundColor: hexToRgba(survivorBlueComp, 0.2),
                                        borderColor: survivorBlueComp,
                                        borderWidth: 2,
                                        fill: true,
                                        tension: 0.4,
                                        pointRadius: 3,
                                        pointHoverRadius: 5,
                                        pointBackgroundColor: survivorBlueComp,
                                        pointBorderColor: survivorBlueComp
                                    },
                                    {
                                        label: 'Killer BP',
                                        data: killerValues,
                                        backgroundColor: hexToRgba(failureColorComp, 0.2),
                                        borderColor: failureColorComp,
                                        borderWidth: 2,
                                        fill: true,
                                        tension: 0.4,
                                        pointRadius: 3,
                                        pointHoverRadius: 5,
                                        pointBackgroundColor: failureColorComp,
                                        pointBorderColor: failureColorComp
                                    }
                                ]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                interaction: {
                                    mode: 'index',
                                    intersect: false
                                },
                                plugins: {
                                    legend: {
                                        display: true,
                                        position: 'top',
                                        labels: {
                                            color: textPrimary,
                                            usePointStyle: true,
                                            padding: 15,
                                            filter: function(item) {
                                                // Only show legend for bar charts, not trend lines
                                                return !item.text.includes('Trend');
                                            }
                                        }
                                    },
                                    tooltip: {
                                        callbacks: {
                                            title: function(context) {
                                                const binStart = parseInt(sortedLabels[context[0].dataIndex]);
                                                const binEnd = binStart + binSize;
                                                return `${binStart.toLocaleString()} - ${binEnd.toLocaleString()} BP`;
                                            },
                                            label: function(context) {
                                                const datasetLabel = context.dataset.label;
                                                const percentage = context.parsed.y.toFixed(1);
                                                return `${datasetLabel}: ${percentage}%`;
                                            }
                                        },
                                        titleColor: textPrimary,
                                        bodyColor: textPrimary,
                                        backgroundColor: bgSecondary,
                                        borderColor: borderColor,
                                        borderWidth: 1
                                    }
                                },
                                scales: {
                                    y: {
                                        beginAtZero: true,
                                        max: 35,
                                        ticks: {
                                            color: textPrimary,
                                            callback: function(value) {
                                                return value.toFixed(0) + '%';
                                            }
                                        },
                                        grid: {
                                            color: gridColor
                                        }
                                    },
                                    x: {
                                        ticks: {
                                            color: textPrimary,
                                            maxRotation: 45,
                                            minRotation: 45
                                        },
                                        grid: {
                                            color: gridColor
                                        }
                                    }
                                }
                            }
                        });
                        chartInstances.push(comparisonChart);
                    }
                }
            }
        }
        
        // Load scatter plot data for Map Area only
        async function loadMapAreaScatter() {
            try {
                const response = await fetch('/scatter_data', {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' }
                });
                const data = await response.json();
                
                if (response.ok && data.scatter_plots && data.scatter_plots.map_area_vs_escape) {
                    displayMapAreaScatter(data.scatter_plots.map_area_vs_escape);
                }
            } catch (error) {
                console.error('Failed to load map area scatter plot:', error);
            }
        }
        
        function displayMapAreaScatter(plotData) {
            const ctx = document.getElementById('scatter-map-area');
            if (!ctx) return;
            
            const root = getComputedStyle(document.documentElement);
            const textPrimary = root.getPropertyValue('--text-primary').trim();
            const bgSecondary = root.getPropertyValue('--bg-secondary').trim();
            const borderColor = root.getPropertyValue('--border-color').trim();
            const accentRed = root.getPropertyValue('--accent-red').trim();
            const successColor = root.getPropertyValue('--color-success').trim();
            const failureColor = root.getPropertyValue('--color-failure').trim();
            
            const gridColor = root.getPropertyValue('--bg-primary').trim() === '#0a0a0a' 
                ? 'rgba(255, 255, 255, 0.1)' 
                : 'rgba(0, 0, 0, 0.1)';
            
            const points = plotData.data.map(d => ({ x: d.x, y: d.y }));
            const pointColors = plotData.data.map(d => d.y >= 50 ? successColor : failureColor);
            const pointSizes = plotData.data.map(d => Math.max(3, Math.min(10, Math.sqrt(d.count) * 0.5)));
            
            // Calculate trend line (simple linear regression)
            const n = points.length;
            const sumX = points.reduce((sum, p) => sum + p.x, 0);
            const sumY = points.reduce((sum, p) => sum + p.y, 0);
            const sumXY = points.reduce((sum, p) => sum + p.x * p.y, 0);
            const sumX2 = points.reduce((sum, p) => sum + p.x * p.x, 0);
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            // Determine direction
            const direction = slope > 0 ? 'positive' : slope < 0 ? 'negative' : 'neutral';
            const directionText = slope > 0 ? 'increasing' : slope < 0 ? 'decreasing' : 'flat';
            
            // Update note with trend information
            const noteElement = document.getElementById('mapAreaScatterNote');
            if (noteElement) {
                const equation = `y = ${slope.toFixed(4)}x + ${intercept.toFixed(2)}`;
                noteElement.textContent = `Trend: ${directionText} (${equation})`;
            }
            
            const minX = Math.min(...points.map(p => p.x));
            const maxX = Math.max(...points.map(p => p.x));
            const trendLine = [
                { x: minX, y: slope * minX + intercept },
                { x: maxX, y: slope * maxX + intercept }
            ];
            
            const scatterChart = new Chart(ctx, {
                        type: 'scatter',
                        data: {
                            datasets: [
                                {
                                    label: 'Escape Rate',
                                    data: points,
                                    backgroundColor: pointColors.map(c => hexToRgba(c, 0.6)),
                                    borderColor: pointColors,
                                    borderWidth: 2,
                                    pointRadius: pointSizes,
                                    pointHoverRadius: pointSizes.map(s => s + 2)
                                },
                                {
                                    label: 'Trend Line',
                                    data: trendLine,
                                    type: 'line',
                                    borderColor: accentRed,
                                    borderWidth: 2,
                                    borderDash: [5, 5],
                                    pointRadius: 0,
                                    fill: false,
                                    tension: 0
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: {
                                mode: 'point',
                                intersect: false
                            },
                            plugins: {
                                legend: {
                                    display: true,
                                    position: 'top',
                                    labels: {
                                        color: textPrimary,
                                        usePointStyle: true,
                                        filter: function(item) {
                                            return item.datasetIndex === 0;
                                        }
                                    }
                                },
                                tooltip: {
                                    callbacks: {
                                        title: function(context) {
                                            const index = context[0].dataIndex;
                                            const dataPoint = plotData.data[index];
                                            return `${plotData.x_label}: ${dataPoint.x.toLocaleString()}`;
                                        },
                                        label: function(context) {
                                            const index = context.dataIndex;
                                            const dataPoint = plotData.data[index];
                                            return [
                                                `${plotData.y_label}: ${dataPoint.y}%`,
                                                `Sample Size: ${dataPoint.count}`,
                                                `Escapes: ${dataPoint.escapes}`
                                            ];
                                        }
                                    },
                                    titleColor: textPrimary,
                                    bodyColor: textPrimary,
                                    backgroundColor: bgSecondary,
                                    borderColor: borderColor,
                                    borderWidth: 1
                                }
                            },
                            scales: {
                                x: {
                                    title: {
                                        display: true,
                                        text: plotData.x_label,
                                        color: textPrimary,
                                        font: { size: 14, weight: 'bold' }
                                    },
                                    ticks: {
                                        color: textPrimary,
                                        callback: function(value) {
                                            return value.toLocaleString();
                                        }
                                    },
                                    grid: {
                                        color: gridColor
                                    }
                                },
                                y: {
                                    title: {
                                        display: true,
                                        text: plotData.y_label,
                                        color: textPrimary,
                                        font: { size: 14, weight: 'bold' }
                                    },
                                    ticks: {
                                        color: textPrimary,
                                        callback: function(value) {
                                            return value.toFixed(0) + '%';
                                        }
                                    },
                                    grid: {
                                        color: gridColor
                                    },
                                    min: 0,
                                    max: 50
                                }
                            }
                        }
                    });
                    chartInstances.push(scatterChart);
        }
        
        // Load dashboard on page load
        loadDashboard();
        
        // Load map area scatter plot after dashboard loads
        setTimeout(() => {
            loadMapAreaScatter();
            loadMatchOutcomes();
        }, 500);
        
        // Load match outcomes data
        async function loadMatchOutcomes() {
            try {
                // Wait for canvas elements to exist (they're created in displayDashboard)
                let retries = 0;
                const maxRetries = 10;
                while (retries < maxRetries && !document.getElementById('chart-match-outcomes')) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    retries++;
                }
                
                const response = await fetch('/match_outcomes', {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' }
                });
                const data = await response.json();
                
                if (response.ok && data.outcomes) {
                    displayMatchOutcomes(data);
                }
            } catch (error) {
                console.error('Failed to load match outcomes:', error);
            }
        }
        
        function displayMatchOutcomes(data) {
            const ctx = document.getElementById('chart-match-outcomes');
            if (!ctx) return;
            
            // Destroy existing chart if it exists
            const existingChart = Chart.getChart(ctx);
            if (existingChart) {
                existingChart.destroy();
            }
            
            const root = getComputedStyle(document.documentElement);
            const textPrimary = root.getPropertyValue('--text-primary').trim();
            const bgSecondary = root.getPropertyValue('--bg-secondary').trim();
            const borderColor = root.getPropertyValue('--border-color').trim();
            const accentRed = root.getPropertyValue('--accent-red').trim();
            const successColor = root.getPropertyValue('--color-success').trim();
            const failureColor = root.getPropertyValue('--color-failure').trim();
            
            const gridColor = root.getPropertyValue('--bg-primary').trim() === '#0a0a0a' 
                ? 'rgba(255, 255, 255, 0.1)' 
                : 'rgba(0, 0, 0, 0.1)';
            
            // Update note
            const noteElement = document.getElementById('matchOutcomesNote');
            if (noteElement) {
                noteElement.textContent = `Total Matches: ${data.total_matches.toLocaleString()}`;
            }
            
            // Prepare data for stacked bar chart
            const labels = data.outcomes.map(o => o.label);
            const indoorData = data.outcomes.map(o => o.indoor);
            const outdoorData = data.outcomes.map(o => o.outdoor);
            const percentages = data.outcomes.map(o => o.percentage);
            
            // Color scheme for map types
            // Indoor maps - use a darker/more muted color
            const indoorColor = '#6b46c1';  // Purple-ish for indoor
            const outdoorColor = '#059669';  // Green for outdoor
            
            const matchOutcomesChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Indoor Maps',
                            data: indoorData,
                            backgroundColor: hexToRgba(indoorColor, 0.7),
                            borderColor: indoorColor,
                            borderWidth: 2
                        },
                        {
                            label: 'Outdoor Maps',
                            data: outdoorData,
                            backgroundColor: hexToRgba(outdoorColor, 0.7),
                            borderColor: outdoorColor,
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: textPrimary,
                                usePointStyle: true,
                                padding: 15
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const index = context.dataIndex;
                                    const datasetLabel = context.dataset.label;
                                    const value = context.parsed.y;
                                    const total = indoorData[index] + outdoorData[index];
                                    const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                    return [
                                        `${datasetLabel}: ${value.toLocaleString()}`,
                                        `Percentage of ${labels[index]}: ${percentage}%`
                                    ];
                                },
                                footer: function(tooltipItems) {
                                    const index = tooltipItems[0].dataIndex;
                                    const total = indoorData[index] + outdoorData[index];
                                    const totalPercentage = percentages[index];
                                    return [
                                        `Total: ${total.toLocaleString()} matches (${totalPercentage}% of all matches)`
                                    ];
                                }
                            },
                            titleColor: textPrimary,
                            bodyColor: textPrimary,
                            backgroundColor: bgSecondary,
                            borderColor: borderColor,
                            borderWidth: 1
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            title: {
                                display: true,
                                text: 'Match Outcome',
                                color: textPrimary,
                                font: { size: 14, weight: 'bold' }
                            },
                            ticks: {
                                color: textPrimary,
                                maxRotation: 0,
                                minRotation: 0
                            },
                            grid: {
                                color: gridColor
                            }
                        },
                        y: {
                            stacked: true,
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Matches',
                                color: textPrimary,
                                font: { size: 14, weight: 'bold' }
                            },
                            ticks: {
                                color: textPrimary,
                                stepSize: 1
                            },
                            grid: {
                                color: gridColor
                            }
                        }
                    }
                }
            });
            chartInstances.push(matchOutcomesChart);
            
            // Load additional breakdown charts if data is available
            if (data.medkit_breakdown) {
                displayBreakdownChart('chart-match-medkits', data.medkit_breakdown, 'Number of Medkits', [0, 1, 2, 3, 4]);
            }
            if (data.flashlight_breakdown) {
                displayBreakdownChart('chart-match-flashlights', data.flashlight_breakdown, 'Number of Flashlights', [0, 1, 2, 3, 4]);
            }
            if (data.second_chance_breakdown) {
                displayBreakdownChart('chart-match-second-chance', data.second_chance_breakdown, 'Number of Survivors with Second Chance Perks', [0, 1, 2, 3, 4]);
            }
            if (data.chase_perks_breakdown) {
                displayBreakdownChart('chart-match-chase-perks', data.chase_perks_breakdown, 'Total Chase Perks', ['0-3', '4-6', '7-9', '10-12']);
            }
        }
        
        function displayBreakdownChart(canvasId, breakdownData, xAxisTitle, valueRange) {
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;
            
            // Destroy existing chart if it exists
            const existingChart = Chart.getChart(ctx);
            if (existingChart) {
                existingChart.destroy();
            }
            
            const root = getComputedStyle(document.documentElement);
            const textPrimary = root.getPropertyValue('--text-primary').trim();
            const bgSecondary = root.getPropertyValue('--bg-secondary').trim();
            const borderColor = root.getPropertyValue('--border-color').trim();
            const accentRed = root.getPropertyValue('--accent-red').trim();
            
            const gridColor = root.getPropertyValue('--bg-primary').trim() === '#0a0a0a' 
                ? 'rgba(255, 255, 255, 0.1)' 
                : 'rgba(0, 0, 0, 0.1)';
            
            const labels = breakdownData.map(o => o.label);
            
            // Create datasets for each value in the range with distinct, muted colors
            const distinctColors = [
                '#6b9bd1',  // Muted Blue
                '#7fb069',  // Muted Green
                '#d4a574',  // Muted Orange/Tan
                '#b88fc7',  // Muted Purple
                '#7fb3b3',  // Muted Teal
                '#c97a7a',  // Muted Red
                '#c4b87a',  // Muted Yellow/Olive
                '#9b8fb8',  // Muted Lavender
                '#7a9b9b',  // Muted Blue-Gray
                '#b89b7a',  // Muted Brown
                '#8fa8b8',  // Muted Slate
                '#7a9b7a',  // Muted Sage
                '#9b7a7a'   // Muted Rose
            ];
            
            const datasets = valueRange.map((value, index) => {
                const valueStr = String(value);
                const data = breakdownData.map(outcome => outcome.data[valueStr] || 0);
                
                // Use distinct colors from the palette
                const colorIndex = index % distinctColors.length;
                const color = distinctColors[colorIndex];
                
                return {
                    label: `${value}`,
                    data: data,
                    backgroundColor: hexToRgba(color, 0.7),
                    borderColor: color,
                    borderWidth: 2
                };
            }).filter(dataset => {
                // Only include datasets that have at least one non-zero value
                return dataset.data.some(val => val > 0);
            });
            
            const chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: textPrimary,
                                usePointStyle: true,
                                padding: 10,
                                font: { size: 11 }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    // Only show non-zero values
                                    if (context.parsed.y === 0 || context.parsed.y === null) {
                                        return null;
                                    }
                                    const datasetLabel = context.dataset.label;
                                    const value = context.parsed.y;
                                    const index = context.dataIndex;
                                    const total = breakdownData[index].data ? 
                                        Object.values(breakdownData[index].data).reduce((sum, v) => sum + (v || 0), 0) : 0;
                                    const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                    return `${datasetLabel}: ${value.toLocaleString()} (${percentage}%)`;
                                },
                                filter: function(tooltipItem) {
                                    // Only show tooltips for non-zero values
                                    return tooltipItem.parsed.y > 0;
                                }
                            },
                            titleColor: textPrimary,
                            bodyColor: textPrimary,
                            backgroundColor: bgSecondary,
                            borderColor: borderColor,
                            borderWidth: 1
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            title: {
                                display: true,
                                text: 'Match Outcome',
                                color: textPrimary,
                                font: { size: 12, weight: 'bold' }
                            },
                            ticks: {
                                color: textPrimary,
                                maxRotation: 0,
                                minRotation: 0,
                                font: { size: 10 }
                            },
                            grid: {
                                color: gridColor
                            }
                        },
                        y: {
                            stacked: true,
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Matches',
                                color: textPrimary,
                                font: { size: 12, weight: 'bold' }
                            },
                            ticks: {
                                color: textPrimary,
                                stepSize: 1,
                                font: { size: 10 }
                            },
                            grid: {
                                color: gridColor
                            }
                        }
                    }
                }
            });
            chartInstances.push(chart);
        }
    </script>
</body>
</html>


